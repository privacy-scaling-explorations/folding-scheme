// code forked from:
// https://github.com/EspressoSystems/hyperplonk/tree/main/subroutines/src/poly_iop/sum_check
//
// Copyright (c) 2023 Espresso Systems (espressosys.com)
// This file is part of the HyperPlonk library.

// You should have received a copy of the MIT License
// along with the HyperPlonk library. If not, see <https://mit-license.org/>.

//! This module defines structs that are shared by all sub protocols.

use crate::{
    folding::circuits::sum_check::DensePolynomialVar, utils::virtual_polynomial::VirtualPolynomial,
};
use ark_ec::CurveGroup;
use ark_ff::PrimeField;
use ark_poly::{univariate::DensePolynomial, DenseUVPolynomial};
use ark_r1cs_std::alloc::{AllocVar, AllocationMode};
use ark_relations::r1cs::ConstraintSystemRef;
use ark_serialize::CanonicalSerialize;

/// An IOP proof is a collections of
/// - messages from prover to verifier at each round through the interactive
///   protocol.
/// - a point that is generated by the transcript for evaluation
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct IOPProof<F: PrimeField> {
    pub point: Vec<F>,
    pub proofs: Vec<IOPProverMessage<F>>,
}

impl<F: PrimeField> IOPProof<F> {
    /// Instantiates polynomial received in coeffs format in the passed constraint system
    /// Intended to be called before verifying a sum-check proof in the verifier circuit
    pub fn get_poly_vars_from_sumcheck_proof(
        &self,
        cs: ConstraintSystemRef<F>,
    ) -> Vec<DensePolynomialVar<F>> {
        let mut poly_vars = Vec::with_capacity(self.proofs.len());
        self.proofs.iter().for_each(|message| {
            let poly_received = DensePolynomial::from_coefficients_slice(&message.coeffs);
            let poly_received_var = DensePolynomialVar::new_variable(
                cs.clone(),
                || Ok(poly_received),
                AllocationMode::Witness,
            )
            .unwrap();
            poly_vars.push(poly_received_var);
        });
        poly_vars
    }
}

/// A message from the prover to the verifier at a given round
/// is a list of coeffs.
#[derive(Clone, Debug, Default, PartialEq, Eq, CanonicalSerialize)]
pub struct IOPProverMessage<F: PrimeField> {
    pub(crate) coeffs: Vec<F>,
}

/// Prover State of a PolyIOP.
#[derive(Debug)]
pub struct IOPProverState<C: CurveGroup> {
    /// sampled randomness given by the verifier
    pub challenges: Vec<C::ScalarField>,
    /// the current round number
    pub(crate) round: usize,
    /// pointer to the virtual polynomial
    pub(crate) poly: VirtualPolynomial<C::ScalarField>,
    /// points with precomputed barycentric weights for extrapolating smaller
    /// degree uni-polys to `max_degree + 1` evaluations.
    #[allow(clippy::type_complexity)]
    pub(crate) extrapolation_aux: Vec<(Vec<C::ScalarField>, Vec<C::ScalarField>)>,
}

/// Verifier State of a PolyIOP, generic over a curve group
#[derive(Debug)]
pub struct IOPVerifierState<C: CurveGroup> {
    pub(crate) round: usize,
    pub(crate) num_vars: usize,
    pub(crate) finished: bool,
    /// a list storing the univariate polynomial in evaluation form sent by the
    /// prover at each round
    pub(crate) polynomials_received: Vec<Vec<C::ScalarField>>,
    /// a list storing the randomness sampled by the verifier at each round
    pub(crate) challenges: Vec<C::ScalarField>,
}
